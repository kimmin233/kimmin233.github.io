---
title: "[ch03-1] 혼자 공부하는 머신러닝 + 딥러닝"
description: 회귀 알고리즘과 모델 규제
categories: 
 - 혼공머신
tags: [AI, Machine Learning, Deep Learning]
---

<!-- 내용 -->

# 03-1 k-최근접 이웃 회귀

<br>
이번 챕터에서는 농어의 데이터 중 길이, 높이, 두께가 제공된다. <br>
세 개의 데이터 중 두 개의 데이터로 나머지 하나의 데이터를 예측할 수 있을까? <br>

### k-최근접 이웃 회귀

지도 학습 알고리즘은 크게 분류와 **회귀(regression)**로 나뉜다. <br>
앞 2장에서 배운 **분류**는 샘플을 **몇 개의 클래스 중 하나로 분류**하는 것이고 <br>
**회귀**는 **임의의 어떤 숫자를 예측하는** 것이다. <br>

예를 들면 내년도 경제 성장률을 예측하거나 배달 도착 시간을 예측하는 것이 회귀 문제다. <br> 
또한 여기서 주어진 문제처럼 농어의 무게를 예측하는 것도 회귀가 된다. <br>
회귀는 정해진 클래스가 없고 **임의의 수치를 출력**한다. <br>

2장에서 배운 k-최근접 이웃 알고리즘이 분류뿐만 아니라 회귀에도 작동한다. <br>
분류 알고리즘으로 먼저 예를 들자면, <br>
예측하려는 샘플에 가장 가까운 샘플 k개를 선택하고, 이 샘플들의 클래스를 확인해 다수 클래스를 새로운 샘플의 클래스로 예측한다. <br>
![03_1_1](/assets/images/ch03/03_1_1.jpg "'샘플'이란 새로운 샘플")
위 그림을 예를 들면 k = 3이고, '샘플'이란 샘플의 가장 가까운 샘플이 2개의 사각형과 1개의 원이면 <br>
사각형이 2개로 **다수**이기 때문에 '샘플'의 클래스는 사각형이 된다.<br><br>

똑같이 회귀에도 적용을 하면 예측하려는 새로운 샘플에 가장 가까운 샘플 k개를 선택하고 <br>
샘플들의 수치로 **평균**을 구해 새로운 샘플의 타깃을 예측한다. <br>
![03_1_2](/assets/images/ch03/03_1_2.jpg)
위 그림에서 이웃한 샘플의 타깃값이 각각 100, 80, 60이므로 평균은 (100+80+60)/3 = 80, 즉 새로운 샘플의 타깃값은 80이 된다. <br>

그럼 이제 농어의 데이터를 준비하고 사이킷런을 사용해 회귀 모델을 훈련해보자.


### 데이터 준비

여기선 농어의 길이만 있어도 무게를 예측할 수 있다고 생각했다. <br>
그렇다면 농어의 **길이가 특성**이고 **무게가 타깃**이 된다. <br>
넘파이 배열로 바로 만들어보자. <br>

👉 [농어의 길이와 무게 데이터](https://gist.github.com/rickiepark/2cd82455e985001542047d7d55d50630)

```python
import numpy as np
perch_length = np.array([8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0, 21.0,
       21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5, 22.5, 22.7,
       23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5, 27.3, 27.5, 27.5,
       27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0, 36.5, 36.0, 37.0, 37.0,
       39.0, 39.0, 39.0, 40.0, 40.0, 40.0, 40.0, 42.0, 43.0, 43.0, 43.5,
       44.0])
perch_weight = np.array([5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0,
       115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0,
       150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0,
       218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0,
       556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0,
       850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0,
       1000.0])
```
<br>
이 데이터들이 어떤 형태를 띠고 있는지 산점도를 그려 확인해보자.
```python
import matplotlib.pyplot as plt
plt.scatter(perch_length, perch_weight)
plt.xlabel('length')
plt.ylabel('weight')
plt.show()
```

![03_1_3](/assets/images/ch03/03_1_3.JPG)

약간 당연하지만 길이가 길어짐에 따라 무게도 늘어나는 것을 알 수 있다. <br>

농어 데이터를 훈련 세트와 테스트 세트로 나누자.
```python
from sklearn.model_selection import train_test_split
train_input, test_input, train_target, test_target = train_test_split(perch_length, perch_weight, random_state = 42)
```

 > 일관성을 위해 2장처럼 random_state는 42로!!


~~길이와 무게를 한 쌍으로 묶어야 하기 때문에 훈련 세트는 넘파이 2차원 배열이어야 한다.~~ <br>
perch_length가 1차원 배열이라서 이걸 나눈 train_input과 test_input도 1차원 배열이라 이걸 다 2차원 배열로 바꿔줘야 한다. <br>

 > 1차원 배열에서 열이 한 개인 2차원 배열로 바꾼다. <br>
   (N, )인 1차원 배열을 (N, 1)인 2차원 배열로


넘파이에서 수동으로 배열의 크기를 바꿀 수 있는 **reshape()** 메서드를 사용해 train_input과 test_input을 2차원 배열로 바꿔보자.
![03_1_4](/assets/images/ch03/03_1_4.JPG)

train_input의 크기는 (42, )이고 이걸 (42, 1)로 바꾸려면 **train_input.reshape(42, 1)** 를 사용해 바꿀 수 있다. <br>
배열의 크기를 아는 경우 이렇게 사용하면 되지만 크기를 따로 확인하지 않고 reshape 하려면<br>
(N, 1)에서 배열의 크기에 해당하는 N에 **-1**을 넣으면 크기에 맞게 자동으로 변경된다. <br>

두 코드를 비교해보자.
![03_1_5](/assets/images/ch03/03_1_5.JPG)
![03_1_6](/assets/images/ch03/03_1_6.JPG)

두 코드 다 같은 동작을 한다. <br>
test_input도 2차원 배열로 바꿔줘야 하기 때문에 reshape(-1, 1)을 사용해서 코드를 짜보자.
```python
train_input = train_input.reshape(-1, 1)
test_input = test_input.reshape(-1, 1)
print(train_input.shape, test_input.shape)
```

![03_1_7](/assets/images/ch03/03_1_7.JPG)
